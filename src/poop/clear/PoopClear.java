package poop.clear;

import static java.lang.String.format;
import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class PoopClear {

	private Path path;

	private List<String> lines;
	
	private static final String FOREACH_REGEX = ".*<xsl:for-each select=\"(.*)\">.*";
	private static final String END_FOREACH_REGEX = ".*<\\/xsl:for-each>.*";	
	private static final String COMMENTS_REGEX = ".*(?!<!--User Editing allowed BELOW this line - DO NOT DELETE THIS LINE-->)(?!<!--SPECIFICATION OF MAP SOURCES AND TARGETS, DO NOT MODIFY.-->)(?!<!--GENERATED BY ORACLE XSL MAPPER )(?=<!--).*";
	private static final String TEST_REGEX = ".*\\stest=\\\".*\\s.*\\\".*";
	private static final String VARIABLE_REGEX = ".*<xsl:variable\\s.*.";
	private static final String VALUEOF_REGEX = ".*<xsl:value-of select=\\\"*.\\/.*:(.*)\\\"\\/>.*";
	
	
	public PoopClear(String file) {
		this.path = Paths.get(file);
	}

	private void print(String value) {
		System.out.println(value);
	}

	public void findPoop() {
		try {
			lines = Files.readAllLines(path);
			for (int i = 0; i < lines.size(); i++) {
				if (lines.get(i).matches(FOREACH_REGEX)) {
					int forEachOpen = 1;
					String poopTest = "(.*)" + lines.get(i).replaceFirst(FOREACH_REGEX, "$1/").replaceAll("/", "\\/") + "(.*)";
					print(lines.get(i).trim());
					for (int j = i; j < lines.size(); j++) {
						if (lines.get(j).matches(poopTest)) {
							print("    replace:" + lines.get(j).trim());
							lines.set(j, lines.get(j).replaceFirst(poopTest, "$1$2"));
							print("    to:" + lines.get(j).trim());
						}
						//logic to break sub loop
						if (lines.get(j).matches(FOREACH_REGEX)) {
							++forEachOpen;
						}
						if (lines.get(j).matches(END_FOREACH_REGEX)) {
							--forEachOpen;
						}
						if (forEachOpen == 0) {
							break;
						}
					}
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void findLogic() {
		try (var files = Files.walk(Files.isDirectory(path) ? path : path.getParent())) {			
			files.filter(f -> f.toString().endsWith(".xsl"))
				.forEach(f -> {
					try {
						var fileLines = Files.readAllLines(f);
						boolean findFile = false;
						for (int i = 0; i < fileLines.size(); i++) {
							var line = fileLines.get(i);
							var find = line.matches(COMMENTS_REGEX) || line.matches(TEST_REGEX) || line.matches(VARIABLE_REGEX);							
							if (line.matches(VALUEOF_REGEX)) {
								if (fileLines.get(i - 1).indexOf(line.replaceFirst(VALUEOF_REGEX, "$1")) < 0) {
									find = true;
								}
							}
							if (! findFile && find) {
								findFile = true;
								print(f.toString());
							}							
							if (find) {
								print(format("\tLine %d: %s", i, line));
							}
						}
					} catch (IOException e) {
						e.printStackTrace();
					}
				});
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public void fixPoop() {
		findPoop();
		try {
			Files.write(this.path, this.lines, TRUNCATE_EXISTING);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

}
